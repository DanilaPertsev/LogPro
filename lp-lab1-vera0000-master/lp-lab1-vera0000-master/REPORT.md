# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Макаренкова В.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    22.12     |     3         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Любой список в Прологе можно представить как двоичное дерево, в листьях которого находятся элементы списка или пустой список. Элементами списка могут быть любые объекты. То есть он либо пуст, либо состоит из 2х частей: головы и хвоста, который сам является списком.

То, что называется списком в императивных языках, сильно отличается от списка в Прологе. Не во всех императивных языках есть такая структура данных, как список. Обрабатывать элементы списка в Прологе можно только рекурсивно, разделяя список на голову и хвост. В императивных языках, чтобы обратиться к какому-то элементу списка, мы можем использовать итераторы. Список в императивном языке может содержать в себе только элементы одинкового типа, в Прологе списки содержат любые элементы.

## Задание 1.1: Предикат обработки списка

`replace_item(N, Item, [X|Xs], [X|Ys])` - Замена N-ого элемента списка на указанный

Примеры использования:
```prolog
?- replace_item(3,7,[1,2,0,6,9],L).
L = [1, 2, 7, 6, 9] .

?- replace_item(3,300,[1,2,300,6,0],L).
L = [1, 2, 300, 6, 0] .

?- replace([1,2,0,6,9],3,7,L).
L = [1, 2, 7, 6, 9] 

?- replace([1,2,300,6,9],3,300,L).
L = [1, 2, 300, 6, 9] 
```

Реализация:
```prolog
%замена n-ого элемента списка на указанный
%без встроенных предикатов обработки (номер элемента,
% значение, которое нужно вставить, список, результирующий список)

replace_item(1, Item, [_|Xs], [Item|Xs]).
replace_item(N, Item, [X|Xs], [X|Ys]) :-
    N1 is N - 1,
    replace_item(N1, Item, Xs, Ys).
% с помощью встроенных предикатов обработки (список, номер элемента,
% значение, которое нужно вставить, результирующий список)

replace([],_,_,[]).
replace(L,N,X,L1):-
    N1 is N-1,
    append(A,[Y|B],L), length(A, N1),
    append(A,[X|B],L1).
```

## Задание 1.2: Предикат обработки числового списка

`split([H|Tail],A,B)` - Разделение списка на два относительно первого элемента (по принципу"больше-меньше")

Примеры использования:
```prolog
?- split([9,10,0,3,26,17,8],A,B).
A = [0, 3, 8],
B = [10, 26, 17].
```

Реализация:
```prolog
% Разделение списка на два относительно первого элемента (по принципу
% "больше-меньше")
%(список, список меньше, список больше или
% равно)

proc([],_,[],[]).
proc([H|Tail],X,[H|A],B):-H<X,!,proc(Tail,X,A,B).
proc([H|Tail],X,A,[H|B]):-proc(Tail,X,A,B).

split([H|Tail],A,B):-proc(Tail,H,A,B).

```
Для нормальной работы предиката также описывается вспомогательный предикат `proc([H|Tail],X,[H|A],B)`.

## Задание 2: Реляционное представление данных
Реляционное представление описывает объекты изучения с помощью связей этих объектов с объектами  других типов. Поэтому для получения информации об интересующем объекте необходимо делать запросы к реляционной модели с целью получения некоторого множества ответов, которые удовлетворяют структуре и логике программы.

Преимущества реляционного представления:

*удобное для пользователя представление объектов в виде таблиц
*возможность использования непроцедурных языков для работы
*основа модели - математический аппарат, который позволяется строго описывать операции над данными
независимость данных

Недостатки реляционного представления:

*не все необходимые для описания сферы можно представить в виде таблиц
*большой расход памяти для представления
*низкая скорость при выполнении операции соединения
Задание : 
*Напечатать средний балл для каждого предмета
*Для каждой группы, найти количество не сдавших студентов
*Найти количество не сдавших студентов для каждого из предметов
Данные из two.pl

Пример использования

```prolog
?- averege_mark('Психология',N).
N = 3.9285714285714284.

?- person_from_group(103,N).
N = 3.

?- person_fall_sub('Информатика',N).
N = 2.

```
Реализация
```prolog
% 1) Напечатать средний балл для каждого предмета

% сумма оценок
s_grade([], 0).
s_grade([H|T], N) :- s_grade(T, M), N is H + M.

averege_mark(Subject, Mark) :-
  findall(Grade, grade(_,_,Subject,Grade), Grades),
  s_grade(Grades, M),
  length(Grades, C),
  Mark is M/C.

% 2) Количество несдавших студентов в группе

person_from_group(Group, Number) :-
  setof(Surname, Subject^grade(Group,Surname,Subject,2), List),
  length(List, Number).


% 3) несдавшие из каждого из предметов

person_fall_sub(Subject, Number) :-
  findall(1, grade(_,_,Subject,2), List),
  length(List, Number).

```
Использование встроенных предикатов setof и findall очень удобно в данном задании, так как не приходится прописывать множество дополнительных предикатов.
## Выводы
Данная лабораторная работа является очень полезной с точки зрения получения новых знаний. Были написаны предикаты обработки списков и числовых списков со стандартными и без стандартных предикатов. Так же были реализованы запросы к реляционному представлению данных. Программы на Прологе выглядят простыми, но за ними скрывается мощный логический бэкграунд. В этой работе у нам представилась возможность познакомиться с простыми задачами на prolog, что дает нам базу для решения более сложных заданий в будущем.




