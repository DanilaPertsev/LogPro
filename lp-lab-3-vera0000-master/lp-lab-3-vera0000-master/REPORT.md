#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Макаренкова В.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    20/12     |     3         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение


   Пространство состояний представляет собой набор ситуаций. Из каждой ситуации следует другое, переходящее в него, и так до получения результата. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния -- начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе. Основные стратегии решения такой задачи -- поиск в глубину, поиск в ширину и поиск с итеративным погружением.
Для представления графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким и более удобным, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие граф.

## Задание

   Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые только влево


## Принцип решения
   Основной принцип решения задачи состоит в следующем: идем по списку, проверяем,лежат ли шары в правильной последовательности, если нет, то меняем их местами согласно предикату "состояний". Я использовала 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах dFS, bFS и iter соответсвенно.



Реализуем предикат Step, выполняющий единичное перемещение шаров в зависимости от их относительного расположения.
```prolog
step(A,B):-
    append(Begin,["_","w"|Tail],A),
    append(Begin,["w","_"|Tail],B).

step(A,B):-
    append(Begin,["b","_"|Tail],A),
    append(Begin,["_","b"|Tail],B).

step(A,B):-
    append(Begin,["_","b","w"|Tail],A),
    append(Begin,["w","b","_"|Tail],B).

step(A,B):-
    append(Begin,["b","w","_"|Tail],A),
    append(Begin,["_","w","b"|Tail],B).
```
Предикат Solution выводит результаты предикатов поиска и показывает время работы алгоритма
```prolog
solution(Start, Fin):-
    write('ITERATION METHOD START'), nl,
    get_time(ITER),
    for(Lvl, 1, 20),
    iter([Start], Fin, Way, Lvl),
    answer(Way),
    get_time(ITER1),
    write('ITERATION METHOD END'), nl, nl,
    T is ITER1 - ITER,
    write('TIME IS '), write(T), nl, nl,

    write('DFS START'), nl,
    get_time(DFS),
    dFS(Fin, [Start]),
    get_time(DFS1),
    write('DFS'), nl, nl,
    T1 is DFS1 - DFS,
    write('TIME IS '), write(T1), nl, nl,

    write('BFS START'), nl,
    get_time(BFS),
    bFS([[Start]],Fin,Way),
    answer(Way),
    get_time(BFS1),
    write('BFS END'), nl, nl,
    T2 is BFS1 - BFS,
    write('TIME IS '), write(T2), nl, nl,
    !.
```
## Результаты

```prolog
?- solution(["b","b","b","b","_","w","w","w"],["w","w","w","_","b","b","b","b"]).
ITERATION METHOD START
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
ITERATION METHOD END

TIME IS 0.1187912940979004

DFS START
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
DFS END

TIME IS 0.13808512687683105
BFS START
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
BFS END

TIME IS 0.1534888744354248

true.
```

## Выводы
   В данной лабораторной работе были реализованы 3 алгоритма поиска на языке Prolog для решения задачи на поиск в пространстве состояний. Как оказалось, Prolog в данном случае весьма эффективный инструмент.
	 Все три алгоритма справились со своей задачей, но наиболее эффективно, как видно по результатам времени оказался поиск с итеративным погружением. Так вышло, потому что он является некой модификацией поиска в глубину и в ширину. Отличие его в том, что он ищет кратчайший путь, т.е. если путь нашелся, алгоритм закончил работу и дальше не будет перебирать варианты.
   
   Для различных задач подходят различные виды поиска, и выбор зависит от цели задачи. В условиях ограничения по памяти лучше использовать поиск в глубину, а с целью поиска кратчайшего пути -- поиск в ширину. Поиск с итеративным углублением хоть и избегает экспоненциальной сложности, но пригоден только для самых простых задач. 
   Данная лабораторная работа помогает изучить наиболее распространенные алгоритмы поиска, что обязательно пригодится в последующей работе и просто в обучении





